# js0-grpc: gRPC-Web's Simplest Implementation

A minimalist, dependency-free library that maps gRPC-Web services to native JavaScript async functions.

## Table of Contents

- [Features](#features)
- [Usage Demo](#usage-demo)
- [Design Philosophy](#design-philosophy)
- [Technology Stack](#technology-stack)
- [Directory Structure](#directory-structure)
- [A Little Story](#a-little-story)

## Features

-   **Zero Dependencies:** Built with the native `fetch` API.
-   **Minimalist:** Only two core functions, providing a clean and straightforward approach.
-   **Protobuf-Compatible:** Works seamlessly with Protobuf-generated encode/decode functions.
-   **Modern:** Utilizes modern JavaScript (ESM, async/await).

## Usage Demo

Assume you have a gRPC service defined in `.proto`:

```proto
syntax = "proto3";

package hello;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

You would use a Protobuf compiler to generate `HelloRequest`, `HelloReply` and their `encode`/`decode` functions.

**Client-side implementation:**

```javascript
import grpc from './src/~.js';
import { setBase } from './src/~.js';

// Assume these are generated by your protobuf tool
// E.g., const { HelloRequest, HelloReply } = require('./hello_pb.js');
// And you create wrappers for encoding/decoding
const encodeHelloRequest = (args) => {
  // const request = new HelloRequest();
  // request.setName(args[0]);
  // return request.serializeBinary();
  return new Uint8Array(); // Placeholder
};

const decodeHelloReply = (binary) => {
  // const reply = HelloReply.deserializeBinary(binary);
  // return reply.getMessage();
  return "Hello from server"; // Placeholder
};

// 1. Configure the base URL of your gRPC-Web proxy
setBase('https://my-grpc-proxy.com/');

// 2. Create a service function
const sayHello = grpc(
  'hello.Greeter/SayHello', // Service path
  encodeHelloRequest,       // Request encoder
  decodeHelloReply          // Response decoder
);

// 3. Call the service function like a regular async function
const response = await sayHello('World');
console.log(response); // Outputs: "Hello from server"
```

## Design Philosophy

The library is composed of two modules: `f.js` and `~.js`.

-   **`f.js`**: This module is a lightweight wrapper around the native `fetch` API. It exports `fBin`, a function that requests a resource and returns the response body as a `Uint8Array`, which is the required format for Protobuf binary data.

-   **`~.js`**: This is the core of the library.
    1.  `setBase(url)`: Sets the global base URL for all gRPC services.
    2.  `grpc(name, E, D)`: This is the default export. It's a higher-order function that returns an async function.
        -   `name`: The full path of the gRPC method (e.g., `package.Service/Method`).
        -   `E` (Encoder): A function that takes the client-side arguments and returns a `Uint8Array` (the serialized Protobuf message).
        -   `D` (Decoder): A function that takes a `Uint8Array` (the response from the server) and returns the deserialized JavaScript data.

The call flow is as follows:
`serviceFunction(...args)` -> `Encoder(args)` -> `fBin(baseUrl + name, encodedData)` -> `Decoder(binaryResponse)` -> `result`

This design abstracts the boilerplate of `fetch` calls, headers, and binary data handling, providing a clean, RPC-like experience.

## Technology Stack

-   **Protocol**: gRPC-Web
-   **Serialization**: Protobuf
-   **HTTP Client**: Native `fetch` API
-   **Binary Data**: `Uint8Array`
-   **Modules**: ES Modules (ESM)

## Directory Structure

```
/
├── src/
│   ├── f.js      # fetch wrapper for binary and text data
│   └── ~.js      # Core gRPC service mapping logic
├── test/
│   └── main.js   # Test entry point
├── package.json
└── README.md
```

## A Little Story

gRPC, the underlying technology, was developed by Google and open-sourced in 2015. It stands for "gRPC Remote Procedure Calls" (a recursive acronym). Its origin traces back to an internal Google project named "Stubby," a general-purpose RPC framework used for over a decade to connect the vast number of microservices running within Google's infrastructure. Stubby was designed for massive scale and performance. When Google decided to create an external version, they rebuilt it on modern standards like HTTP/2 and named it gRPC. This heritage is why gRPC is known for its high performance, language-agnostic nature, and robust features like bi-directional streaming, making it a successor to traditional REST APIs for many microservice architectures.
